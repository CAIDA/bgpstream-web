PyBGPStream Tutorial
====================

<h1 class="text-danger">TODO: UPDATE THIS DOCUMENT</h1>

pyBGPStream provides a Python interface to the libBGPStream C library.
More details are available at @@link to pybgpstream overview, whereas
the complete documentation is available at @@link to pybgpstream docs.

Below we provide the following tutorials:

* [Get familiar with the API](#print) ([code]({{ asset('bundles/caidabgpstreamwebhomepage/docs/tutorials/code/tutorial-moas.py') }}))

* [Print the MOAS prefixes](#moas) ([code]({{ asset('bundles/caidabgpstreamwebhomepage/docs/tutorials/code/tutorial-moas.py') }}))

* [Measuring the extent of AS path inflation](#aspath) ([code]({{ asset('bundles/caidabgpstreamwebhomepage/docs/tutorials/code/tutorial-aspath.py') }}))



## Get familiar with the API ##   {% verbatim %}{#print}{% endverbatim %}

Below is a simple example that shows how to use pybgpstream to output
the information extracted from BGP records and BGP elems. The example is fully
functioning and it can be  run using the following command:

~~~
$ python tutorial-print.py
 ris rrc11 update 1438417216 valid A 2001:504:1::a500:9002:1 9002 {'next-hop': '2001:504:1::a500:9002:1', 'prefix': '2001:67c:2c44::/48', 'as-path': '9002 21219 50581 49588'}
 ris rrc11 update 1438417216 valid A 198.32.160.182 9002 {'next-hop': '198.32.160.182', 'prefix': '91.214.14.0/24', 'as-path': '9002 6663 39668 65535 49256'}
 ris rrc11 update 1438417216 valid A 2001:504:1::a500:9002:1 9002 {'next-hop': '2001:504:1::a500:9002:1', 'prefix': '2001:67c:2c44::/48', 'as-path': '9002 13249 49588'}
 ris rrc11 update 1438417216 valid A 198.32.160.182 9002 {'next-hop': '198.32.160.182', 'prefix': '61.7.155.0/24', 'as-path': '9002 2914 3356 4651 131090 131090 131090'}
 ris rrc11 update 1438417216 valid A 198.32.160.103 13030 {'next-hop': '198.32.160.103', 'prefix': '41.221.20.0/24', 'as-path': '13030 30781 57023 57023 57023 57023 36947'}
 ris rrc11 update 1438417216 valid A 198.32.160.182 9002 {'next-hop': '198.32.160.182', 'prefix': '41.221.20.0/24', 'as-path': '9002 3356 12956 36947'}
 ris rrc11 update 1438417216 valid A 198.32.160.182 9002 {'next-hop': '198.32.160.182', 'prefix': '61.7.155.0/24', 'as-path': '9002 3356 4651 131090 131090 131090'}
 ris rrc11 update 1438417216 valid W 198.32.160.42 2497 {'prefix': '103.224.214.0/24'}
 ris rrc11 update 1438417216 valid W 198.32.160.42 2497 {'prefix': '103.224.215.0/24'}
 ris rrc11 update 1438417216 valid A 2001:504:1::a500:9002:1 9002 {'next-hop': '2001:504:1::a500:9002:1', 'prefix': '2001:67c:2c44::/48', 'as-path': '9002 13249 50581 49588'}
 ris rrc11 update 1438417216 valid A 198.32.160.182 9002 {'next-hop': '198.32.160.182', 'prefix': '61.7.155.0/24', 'as-path': '9002 6453 4651 131090 131090 131090'}
 ris rrc11 update 1438417216 valid A 2001:504:1::a500:9002:1 9002 {'next-hop': '2001:504:1::a500:9002:1', 'prefix': '2001:67c:2c44::/48', 'as-path': '9002 13249 49588'}
 ris rrc11 update 1438417216 valid A 198.32.160.182 9002 {'next-hop': '198.32.160.182', 'prefix': '61.7.155.0/24', 'as-path': '9002 3356 4651 131090 131090 131090'}
~~~

### Step by step description

The first step in each program is to import the Python modules and
create a new BGPStream instance as well as a re-usable BGP record
instance.

<br>

~~~ .language-python
from _pybgpstream import BGPStream, BGPRecord, BGPElem

stream = BGPStream()
rec = BGPRecord()
~~~

<br>

The second step consists in customizing the stream using the project,
collector, type, and time interval filters. The time interval filter
is mandatory, whereas the others are optional. In this specific case,
we are configuring the stream to return the BGP records read from
a RIBs dump generated by RIS RRC 10 collector,
having a timestamp equal to Sat, 01 Aug 2015 08:20:16 GMT.

<br>

~~~ .language-python
stream.add_filter('collector','rrc11')
stream.add_interval_filter(1438417216,1438417216)
~~~

<br>

At this point we can start the stream, and repeatedly ask for new
BGP records and BGP elems. Each time a valid record is read, we
extract from it the elems that it contains and print the record and
elem fields. If a non-valid record is found, we do not attempt to
extract elems. 

<br>


~~~ .language-python
while(stream.get_next_record(rec)):
    if rec.status != "valid":
        print rec.project, rec.collector, rec.type, rec.time, rec.status
    else:
        elem = rec.get_next_elem()
        while(elem):
            print rec.project, rec.collector, rec.type, rec.time, rec.status,
            print elem.type, elem.peer_address, elem.peer_asn, elem.fields
            elem = rec.get_next_elem()
~~~


### Complete Example

Get the [code]({{
asset('bundles/caidabgpstreamwebhomepage/docs/tutorials/code/tutorial-print.py')
}}).

~~~ .language-python
{% include '@CAIDABGPStreamWebHomepageBundle/Resources/public/docs/tutorials/code/tutorial-print.py' %}
~~~



## Print the MOAS prefixes ##   {% verbatim %}{#moas}{% endverbatim %}

Below is a simple example that shows how to use pybgpstream to output
the MOAS prefixes and their origin ASes. The example is fully
functioning and it can be  run using the following command:

~~~
$ python moas.py
   194.68.55.0/24 43893,30893
   199.45.53.0/24 701,65403
   207.188.170.0/24 13332,26640
   ...
   193.232.141.0/24 42385,31649
   84.16.224.0/19 28753,16265
   125.208.1.0/24 4808,4847
~~~


The program instantiate an instance of BGPStream that uses the CAIDA
broker as data interface, it parses the BGP elems extracted from the
BGP records that match the filters (collectors, record type, and
time), and saves in a hash map the list of unique origin ASns for each
prefix. 



### Step by step description

In this case the stream is configured to return the BGP records read from
a RIBs dump generated by  Route View Singapore collector,
having a timestamp in the interval 7:50:00 - 08:10:00 Sat, 01 Aug
2015 GMT.
<br>

~~~ .language-python
stream.add_filter('collector','route-views.sg')
stream.add_filter('record-type','ribs')
stream.add_interval_filter(1438415400,1438416600)
~~~

<br>

We  use a dictionary to associate a list of origin ASns to each
prefix observed in the RIB dump.

<br>

~~~ .language-python
from collections import defaultdict

prefix_origin = defaultdict(set)
~~~

<br>

Each time a new BGP elem is extracted, the program extracts the prefix
and the origin ASn and updates the *prefix_origin* dictionary.
Prefix and as-path fields are string fields that are present in any
BGP elem of type RIB. The split function converts the AS path string
into an array of strings, each one representing an AS hop, the last
hop is the origin AS.

<br>

~~~ .language-python
pfx = elem.fields['prefix']
ases = elem.fields['as-path'].split(" ")
if len(ases) > 0:
 origin = ases[-1]
 prefix_origin[pfx].add(origin)
~~~


### Complete Example

Get the [code]({{
asset('bundles/caidabgpstreamwebhomepage/docs/tutorials/code/tutorial-moas.py')
}}).

~~~ .language-python
{% include '@CAIDABGPStreamWebHomepageBundle/Resources/public/docs/tutorials/code/tutorial-moas.py' %}
~~~

## Measuring the extent of AS path inflation ##   {% verbatim %}{#aspath}{% endverbatim %}

Below is a compact example that shows how to use pybgpstream to
measure the extent of AS path inflation, i.e. measure how many AS
paths are longer than the shortest path between two ASes due to the
adoption of routing policies. The example is fully functioning and it
can be  run using the following command: 

~~~
$ python moas.py
   ...
   3549 27316 6 5
   3549 27314 3 3
   3549 27313 3 3
   3549 27310 3 3
   3549 27311 3 3
   3549 45834 4 4
   3549 27318 4 3
   3549 27319 5 4
   3549 18173 4 4
...
~~~


The program instantiate reads a RIB dump as originated by the RIS
RRC00 collector, it computes the number of AS hops between the
peer ASn and the origin AS, and it compares it to the shortest path
between the same AS pairs in an simple undirected graph built using
the AS path adjacencies. The output complies with the following
format:

~~~
<monitor ASn> <destination ASn> <#AS hops in BGP> <#AS hops in undirected graph>
~~~

<br>

### Step by step description

In this case the stream is configured to return the BGP records read from
a RIBs dump generated by RIS RRC00 collector,
having a timestamp in the interval 7:50:00 - 08:10:00 Sat, 01 Aug
2015 GMT.

<br>

~~~ .language-python
stream.add_filter('collector','rrc00')
stream.add_filter('record-type','ribs')
stream.add_interval_filter(1438415400,1438416600)
~~~

<br>

The script uses the [NetworkX](https://networkx.github.io/) package
utilities to generate a simple undirected graph (i.e. a graph that
does not have loops or self-edges).  A dictionary of dictionaries is
used to maintain the shortest path between the peer ASn and the origin ASn
as observed in BGP.

<br>

~~~ .language-python
import networkx as nx
from collections import defaultdict

as_graph = nx.Graph()

bgp_lens = defaultdict(lambda: defaultdict(lambda: None))
~~~

<br>

Each time a new BGP elem is extracted, the program computes the ordered list of
ASns in the AS path, and removes possible repeatedly prepended ASns (using the
groupby function). Each adjacency in the AS path is used to add a new
link to the NetworkX graph, meanwhile the AS path length updates the
*bgp_lens*  dictionary.

<br>

~~~ .language-python
hops = [k for k, g in groupby(elem.fields['as-path'].split(" "))]
if len(hops) > 1 and hops[0] == peer:
            origin = hops[-1]
            for i in range(0,len(hops)-1):
                as_graph.add_edge(hops[i],hops[i+1])
            bgp_lens[peer][origin] = min(filter(bool,[bgp_lens[peer][origin],len(hops)]))
~~~

Finally, for each peer and origin pair, the script uses NetworkX
utility functionst to compute the length of the shortest path between
the two nodes in the undirected graph. The output juxtaposes the
minimum lenght observed in BGP and the shortest path computed in the
undirected graph.

~~~ .language-python
for peer in bgp_lens:
    for origin in bgp_lens[peer]:
       nxlen = len(nx.shortest_path(as_graph, peer, origin))
        print peer, origin, bgp_lens[peer][origin], nxlen
~~~

### Complete Example

Get the [code]({{
asset('bundles/caidabgpstreamwebhomepage/docs/tutorials/code/tutorial-aspath.py')
}}).

~~~ .language-python
{% include '@CAIDABGPStreamWebHomepageBundle/Resources/public/docs/tutorials/code/tutorial-aspath.py' %}
~~~


